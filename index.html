<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Dune Roll — Hold to Roll, Tap to Jump</title>
<style>
  :root {
    --bg: #0b1220;
    --panel: rgba(255, 255, 255, 0.06);
    --accent: #ffd166;
    --muted: #9aa8bf;
    --glass: rgba(255, 255, 255, 0.06);
    --ui-radius: 12px;
  }
  html, body {
    margin: 0; padding: 0; height: 100%;
    font-family: Inter, Segoe UI, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg, #071020 0%, #0b1220 100%);
    color: #e6eef8;
    overflow: hidden;
  }
  #game-wrap {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
  }
  .brand {
    font-weight: 700;
    display: flex;
    gap: 10px;
    align-items: center;
  }
  .brand .dot {
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent);
  }
  .ui-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .stat {
    background: var(--glass);
    padding: 8px 10px;
    border-radius: 10px;
    font-size: 14px;
    color: var(--muted);
    min-width: 80px;
    text-align: center;
  }
  canvas {
    display: block;
    flex: 1;
    width: 100%;
    height: calc(100vh - 84px);
    touch-action: none;
  }
  footer {
    display: flex;
    justify-content: space-between;
    padding: 10px 12px;
  }
  button.ui {
    background: var(--panel);
    border: 1px solid rgba(255, 255, 255, 0.03);
    padding: 8px 12px;
    border-radius: 10px;
    color: #eaf2ff;
    font-weight: 600;
    cursor: pointer;
  }
  button.ui:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  .modal {
    position: fixed;
    left: 50%; top: 50%;
    transform: translate(-50%, -50%);
    width: min(720px, 96vw);
    background: linear-gradient(180deg, #0f1724, #08101b);
    border-radius: 16px;
    padding: 14px;
    border: 1px solid rgba(255, 255, 255, 0.04);
    box-shadow: 0 10px 40px rgba(2, 6, 23, 0.6);
    z-index: 30;
    color: #e6eef8;
  }
  .hidden {
    display: none;
  }
  .shop-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    margin-top: 12px;
  }
  .skin-card {
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
    padding: 10px;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }
  .skin-swatch {
    width: 72px; height: 72px;
    border-radius: 50%;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
  }
  .controls-hint {
    font-size: 13px;
    color: var(--muted);
    margin-top: 6px;
  }
  @media (max-width: 620px) {
    header {
      padding: 8px;
    }
    footer {
      padding: 8px;
    }
    canvas {
      height: calc(100vh - 100px);
    }
  }
</style>
</head>
<body>
<div id="game-wrap">
  <header>
    <div class="brand"><div class="dot"></div>Dune Roll</div>
    <div class="ui-row">
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="air">Air: 0.00s</div>
      <div class="stat" id="coins">Coins: 0</div>
      <div class="stat" id="best">Best: 0</div>
      <button class="ui" id="shopBtn">Shop</button>
      <button class="ui" id="pauseBtn">Pause</button>
    </div>
  </header>

  <canvas id="c"></canvas>

  <footer>
    <div class="controls-hint">Hold mouse or touch to roll. Tap or press Space to jump. Land clean or game over. Jump the line to score.</div>
    <div>
      <button class="ui" id="resetBtn">Reset Progress</button>
    </div>
  </footer>
</div>

<!-- Shop modal -->
<div id="shop" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="shopTitle">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <strong id="shopTitle">Skins & Shop</strong>
    <div style="display:flex;gap:10px;align-items:center"><span id="shopCoins">0</span> <button class="ui" id="closeShop">Close</button></div>
  </div>
  <div class="shop-grid" id="skins"></div>
  <div style="margin-top:12px;font-size:13px;color:var(--muted)">Tip: colored skins are cosmetic only. Earn coins by scoring and collecting pickups.</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.min(window.devicePixelRatio || 1, 2);

  function resize() {
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor((window.innerHeight - 84) * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = (window.innerHeight - 84) + 'px';
  }
  window.addEventListener('resize', resize);
  resize();

  // Persistent state
  let coins = parseInt(localStorage.getItem('dr_coins') || '0', 10) || 0;
  let best = parseInt(localStorage.getItem('dr_best') || '0', 10) || 0;
  let unlockedSkins = JSON.parse(localStorage.getItem('dr_unlocked') || 'null') || ['#ffd166', '#6ee7b7'];
  let chosenSkin = localStorage.getItem('dr_skin') || unlockedSkins[0];
  document.getElementById('best').textContent = 'Best: ' + best;
  document.getElementById('coins').textContent = 'Coins: ' + coins;

  // Terrain functions for gradual hills
  function hill(x) {
    // Sum of sin waves with lower frequency for gentle hills
    return Math.sin(x * 0.002) * 45 + Math.sin(x * 0.0015 + 1000) * 30;
  }
  function groundY(x) {
    const base = canvas.height / DPR * 0.65;
    return base + hill(x);
  }
  function groundSlope(x) {
    const h = 0.5;
    return (groundY(x + h) - groundY(x - h)) / (2 * h);
  }

  // Player ball
  const ball = {
    x: 140,
    y: 0,
    r: 20,
    vx: 0,
    vy: 0,
    onGround: false,
    color: chosenSkin,
    rolling: false,
    jumpRequested: false,
    airtime: 0,
    speedMultiplier: 1,
    dead: false,
  };

  // Horizontal jump line position, moves with player
  let jumpLineX = 0;

  // Score tracking
  let score = 0;
  let highScore = best;

  // Pickups (coins) spawning
  let pickups = [];
  function spawnPickups() {
    while (pickups.length < 5) {
      const px = ball.x + 400 + Math.random() * 1000;
      const py = groundY(px) - 90 - Math.random() * 150;
      pickups.push({ x: px, y: py, r: 9, value: Math.random() < 0.15 ? 5 : 1, collected: false });
    }
  }

  // Controls input state
  let input = { hold: false, tap: false, tapQueued: false };
  let lastTapTime = 0;
  const TAP_THRESHOLD = 250; // ms max between down and up for tap

  function onPointerDown(e) {
    e.preventDefault();
    input.hold = true;
  }
  function onPointerUp(e) {
    e.preventDefault();
    input.hold = false;
    const now = performance.now();
    if (now - lastTapTime < TAP_THRESHOLD) {
      input.tapQueued = true;
    }
    lastTapTime = now;
  }

  canvas.addEventListener('touchstart', onPointerDown, { passive: false });
  canvas.addEventListener('mousedown', onPointerDown);
  window.addEventListener('touchend', onPointerUp, { passive: false });
  window.addEventListener('mouseup', onPointerUp);
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      if (!input.hold) {
        input.tapQueued = true;
      }
      input.hold = true;
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      input.hold = false;
    }
  });

  function jump() {
    if (ball.onGround && !ball.dead) {
      ball.vy = -14 * ball.speedMultiplier;
      ball.onGround = false;
      ball.airtime = 0;
    }
  }

  // Death if landing badly (too steep angle)
  function checkLanding() {
    // Slope angle in radians at landing point
    const slope = groundSlope(ball.x);
    const angle = Math.atan(slope);
    // Acceptable landing angle range - about ±30 degrees
    if (Math.abs(angle) > Math.PI / 6) {
      ball.dead = true;
    }
  }

  // Update function
  let running = true;
  let last = performance.now();
  function update(dt) {
    if (ball.dead) return;

    const secs = dt / 1000;

    // Speed multiplier gradually increases over time up to max 3
    ball.speedMultiplier += secs * 0.06;
    if (ball.speedMultiplier > 3) ball.speedMultiplier = 3;

    // Movement
    if (input.hold) {
      // accelerate to max speed 10 * multiplier
      ball.vx += 0.15 * ball.speedMultiplier;
      if (ball.vx > 10 * ball.speedMultiplier) ball.vx = 10 * ball.speedMultiplier;
      ball.rolling = true;
    } else {
      // slow down
      ball.vx *= 0.94;
      if (ball.vx < 0.1) ball.vx = 0;
      ball.rolling = false;
    }

    // Process jump tap if queued
    if (input.tapQueued) {
      jump();
      input.tapQueued = false;
    }

    // Gravity
    const gravity = 28;
    ball.vy += gravity * secs;

    // Integrate position
    ball.x += ball.vx * secs * 60;
    ball.y += ball.vy * secs * 60;

    // Ground collision
    const gy = groundY(ball.x);
    if (ball.y + ball.r > gy) {
      if (!ball.onGround) {
        // landed just now
        checkLanding();
      }
      ball.y = gy - ball.r;
      ball.vy = 0;
      ball.onGround = true;
      ball.airtime = 0;
    } else {
      ball.onGround = false;
      ball.airtime += secs;
    }

    // Pickups collision
    for (let p of pickups) {
      if (!p.collected && Math.hypot(p.x - ball.x, p.y - ball.y) < ball.r + p.r + 6) {
        p.collected = true;
        coins += p.value;
        localStorage.setItem('dr_coins', coins);
      }
    }
    pickups = pickups.filter(p => !p.collected && p.x > ball.x - 300);
    spawnPickups();

    // Update jump line position a bit ahead
    jumpLineX = ball.x + 220;

    // Score logic - crossing jump line horizontally
    if (!ball.dead && ball.x > jumpLineX) {
      const jumpHeight = ball.airtime;
      // points scale with airtime up to 3 seconds max (cap)
      const points = Math.min(3, jumpHeight) * 10;
      score += Math.floor(points);
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('dr_best', highScore);
        document.getElementById('best').textContent = 'Best: ' + highScore;
      }
      // Move jump line further out for next jump
      jumpLineX += 220;
    }
  }

  // Render function
  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background sky
    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
    sky.addColorStop(0, '#072037');
    sky.addColorStop(1, '#061220');
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Translate world to simulate running
    ctx.save();
    ctx.translate(-ball.x * DPR + 140 * DPR, 0);

    // Draw terrain
    ctx.beginPath();
    ctx.moveTo((ball.x - 800) * DPR, canvas.height);
    const start = Math.floor(ball.x - 800);
    const end = Math.ceil(ball.x + canvas.width / DPR + 800);
    for (let x = start; x <= end; x += 6) {
      const y = groundY(x);
      ctx.lineTo(x * DPR, y * DPR);
    }
    ctx.lineTo(end * DPR, canvas.height);
    ctx.closePath();
    ctx.fillStyle = '#ffdc76';
    ctx.fill();

    // Draw terrain highlight layer for smooth hills
    ctx.beginPath();
    ctx.moveTo((ball.x - 800) * DPR, canvas.height);
    for (let x = start; x <= end; x += 6) {
      const y = groundY(x) - 15;
      ctx.lineTo(x * DPR, y * DPR);
    }
    ctx.lineTo(end * DPR, canvas.height);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.06)';
    ctx.fill();

    // Draw jump line (the horizontal line to jump over)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 4 * DPR;
    ctx.beginPath();
    ctx.moveTo(jumpLineX * DPR, 0);
    ctx.lineTo(jumpLineX * DPR, canvas.height);
    ctx.stroke();

    // Draw pickups (coins)
    for (const p of pickups) {
      const sx = p.x * DPR;
      const sy = p.y * DPR;
      if (sx < (ball.x - 800) * DPR || sx > (ball.x + canvas.width / DPR + 800) * DPR) continue;
      ctx.beginPath();
      ctx.arc(sx, sy, p.r * DPR, 0, Math.PI * 2);
      ctx.fillStyle = p.value > 1 ? '#ffd166' : '#9ad3ff';
      ctx.fill();
      ctx.lineWidth = 2 * DPR;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.stroke();
    }

    // Draw ball shadow
    const bx = 140 * DPR;
    const by = ball.y * DPR;
    ctx.beginPath();
    ctx.ellipse(bx, by + ball.r * DPR + 10 * DPR, ball.r * DPR * 1.2, ball.r * DPR * 0.4, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fill();

    // Draw ball
    ctx.beginPath();
    ctx.arc(bx, by, ball.r * DPR, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    ctx.lineWidth = 2 * DPR;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.stroke();

    // Ball shine highlight
    ctx.beginPath();
    ctx.arc(bx - ball.r * DPR * 0.35, by - ball.r * DPR * 0.45, ball.r * DPR * 0.3, 0, Math.PI * 2);
    const shine = ctx.createRadialGradient(bx - ball.r * DPR * 0.35, by - ball.r * DPR * 0.45, ball.r * DPR * 0.05, bx - ball.r * DPR * 0.35, by - ball.r * DPR * 0.45, ball.r * DPR * 0.35);
    shine.addColorStop(0, 'rgba(255,255,255,0.7)');
    shine.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = shine;
    ctx.fill();

    ctx.restore();
  }

  // Animate loop
  let lastTime = performance.now();
  function loop(now) {
    const dt = now - lastTime;
    lastTime = now;

    if (!ball.dead) update(dt);
    render();

    // Update UI
    document.getElementById('score').textContent = 'Score: ' + score;
    document.getElementById('air').textContent = 'Air: ' + ball.airtime.toFixed(2) + 's';
    document.getElementById('coins').textContent = 'Coins: ' + coins;

    if (ball.dead) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ff6969';
      ctx.textAlign = 'center';
      ctx.font = 'bold 48px Inter, sans-serif';
      ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2);
      ctx.font = 'bold 26px Inter, sans-serif';
      ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
      ctx.font = '16px Inter, sans-serif';
      ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 90);
      ctx.restore();
    } else {
      requestAnimationFrame(loop);
    }
  }
  requestAnimationFrame(loop);

  // Shop and skins
  const skinsData = [
    { color: '#ffd166', price: 0, name: 'Gold' },
    { color: '#6ee7b7', price: 50, name: 'Mint' },
    { color: '#f87171', price: 150, name: 'Red' },
    { color: '#60a5fa', price: 250, name: 'Blue' },
    { color: '#a78bfa', price: 400, name: 'Purple' },
  ];

  const skinsContainer = document.getElementById('skins');
  const shopCoins = document.getElementById('shopCoins');
  const shopModal = document.getElementById('shop');
  const shopBtn = document.getElementById('shopBtn');
  const closeShopBtn = document.getElementById('closeShop');

  function saveSkin(color) {
    chosenSkin = color;
    ball.color = chosenSkin;
    localStorage.setItem('dr_skin', chosenSkin);
  }

  function unlockSkin(color) {
    if (!unlockedSkins.includes(color)) {
      unlockedSkins.push(color);
      localStorage.setItem('dr_unlocked', JSON.stringify(unlockedSkins));
    }
  }

  function createSkinCard(skin) {
    const card = document.createElement('div');
    card.className = 'skin-card';

    const swatch = document.createElement('div');
    swatch.className = 'skin-swatch';
    swatch.style.backgroundColor = skin.color;
    swatch.textContent = skin.name[0];
    card.appendChild(swatch);

    const name = document.createElement('div');
    name.textContent = skin.name;
    card.appendChild(name);

    const price = document.createElement('div');
    price.textContent = skin.price > 0 ? `${skin.price} coins` : 'Free';
    card.appendChild(price);

    const btn = document.createElement('button');
    btn.className = 'ui';
    if (skin.color === chosenSkin) {
      btn.textContent = 'Selected';
      btn.disabled = true;
    } else if (unlockedSkins.includes(skin.color)) {
      btn.textContent = 'Select';
      btn.disabled = false;
    } else {
      btn.textContent = 'Buy';
      btn.disabled = skin.price > coins;
    }

    btn.addEventListener('click', () => {
      if (btn.textContent === 'Buy') {
        if (coins >= skin.price) {
          coins -= skin.price;
          localStorage.setItem('dr_coins', coins);
          unlockSkin(skin.color);
          shopCoins.textContent = coins;
          refreshShop();
          saveSkin(skin.color);
          document.getElementById('coins').textContent = coins;
        } else {
          alert('Not enough coins!');
        }
      } else if (btn.textContent === 'Select') {
        saveSkin(skin.color);
        refreshShop();
      }
    });

    card.appendChild(btn);
    return card;
  }

  function refreshShop() {
    shopCoins.textContent = coins;
    skinsContainer.innerHTML = '';
    for (const skin of skinsData) {
      skinsContainer.appendChild(createSkinCard(skin));
    }
  }

  shopBtn.addEventListener('click', () => {
    refreshShop();
    shopModal.classList.remove('hidden');
  });

  closeShopBtn.addEventListener('click', () => {
    shopModal.classList.add('hidden');
  });

  // Reset progress button
  document.getElementById('resetBtn').addEventListener('click', () => {
    if (confirm('Reset all progress and coins?')) {
      localStorage.clear();
      location.reload();
    }
  });

})();
</script>
</body>
</html>
